"use strict";

var _rollupPluginBabelHelpers = require("./7832a774.js"), core = require("@urql/core"), defaultPageInfo = {
  __typename: "PageInfo",
  endCursor: null,
  startCursor: null,
  hasNextPage: !1,
  hasPreviousPage: !1
}, ensureKey = function(a) {
  return "string" == typeof a ? a : null;
}, concatEdges = function(a, g, e) {
  var c, b, d, r, m;
  for (c = new Set, b = 0, d = g.length; b < d; b++) {
    "string" == typeof (r = a.resolve(g[b], "node")) && c.add(r);
  }
  g = g.slice();
  b = 0;
  for (d = e.length; b < d; b++) {
    "string" != typeof (m = a.resolve(r = e[b], "node")) || c.has(m) || (c.add(m), g.push(r));
  }
  return g;
}, concatNodes = function(a, g) {
  var e, c, b, d;
  for (e = new Set, c = 0, b = a.length; c < b; c++) {
    "string" == typeof (d = a[c]) && e.add(d);
  }
  a = a.slice();
  c = 0;
  for (b = g.length; c < b; c++) {
    "string" != typeof (d = g[c]) || e.has(d) || (e.add(d), a.push(d));
  }
  return a;
}, compareArgs = function(a, g) {
  var e, c, b, d;
  for (e in g) {
    if ("first" !== e && "last" !== e && "after" !== e && "before" !== e) {
      if (!(e in a)) {
        return !1;
      }
      if (typeof (c = a[e]) != typeof (b = g[e]) || "object" != typeof c ? c !== b : core.stringifyVariables(c) !== core.stringifyVariables(b)) {
        return !1;
      }
    }
  }
  for (d in a) {
    if ("first" !== d && "last" !== d && "after" !== d && "before" !== d && !(d in g)) {
      return !1;
    }
  }
  return !0;
}, getPage = function(a, g, e) {
  var b, d, r, m, c = ensureKey(a.resolveFieldByKey(g, e));
  if (!c) {
    return null;
  }
  e = a.resolve(c, "__typename");
  g = a.resolve(c, "edges") || [];
  b = a.resolve(c, "nodes") || [];
  if ("string" != typeof e) {
    return null;
  }
  e = {
    __typename: e,
    edges: g,
    nodes: b,
    pageInfo: defaultPageInfo
  };
  if ("string" == typeof (d = a.resolve(c, "pageInfo"))) {
    c = ensureKey(a.resolve(d, "__typename"));
    b = ensureKey(a.resolve(d, "endCursor"));
    r = ensureKey(a.resolve(d, "startCursor")), m = a.resolve(d, "hasNextPage");
    d = a.resolve(d, "hasPreviousPage");
    null === (c = e.pageInfo = {
      __typename: "string" == typeof c ? c : "PageInfo",
      hasNextPage: "boolean" == typeof m ? m : !!b,
      hasPreviousPage: "boolean" == typeof d ? d : !!r,
      endCursor: b,
      startCursor: r
    }).endCursor && (b = g[g.length - 1]) && (b = a.resolve(b, "cursor"), c.endCursor = ensureKey(b));
    null === c.startCursor && (g = g[0]) && (a = a.resolve(g, "cursor"), c.startCursor = ensureKey(a));
  }
  return e;
};

exports.relayPagination = function(a) {
  void 0 === a && (a = {});
  var g = a.mergeMode || "inwards";
  return function(a, c, b, d) {
    var e, m, v, t, u, q, n, k, l, p, h, f, w, x;
    e = d.fieldName;
    if (0 !== (v = (m = b.inspectFields(a = d.parentKey).filter((function(a) {
      return a.fieldName === e;
    }))).length)) {
      for (t = null, u = [], q = [], n = [], k = [], l = _rollupPluginBabelHelpers._extends({}, defaultPageInfo), 
      p = 0; p < v; p++) {
        f = (h = m[p]).fieldKey;
        if (null !== (h = h.arguments) && compareArgs(c, h) && null !== (f = getPage(b, a, f))) {
          if ("inwards" === g && "number" == typeof h.last && "number" == typeof h.first) {
            l = f.edges.slice(0, h.first + 1);
            w = f.edges.slice(-h.last), x = f.nodes.slice(0, h.first + 1);
            h = f.nodes.slice(-h.last);
            u = concatEdges(b, u, l);
            q = concatEdges(b, w, q);
            n = concatNodes(n, x);
            k = concatNodes(h, k);
            l = f.pageInfo;
          } else {
            h.after ? (u = concatEdges(b, u, f.edges), n = concatNodes(n, f.nodes), l.endCursor = f.pageInfo.endCursor, 
            l.hasNextPage = f.pageInfo.hasNextPage) : h.before ? (q = concatEdges(b, f.edges, q), 
            k = concatNodes(f.nodes, k), l.startCursor = f.pageInfo.startCursor, l.hasPreviousPage = f.pageInfo.hasPreviousPage) : ("number" == typeof h.last ? (q = concatEdges(b, q, f.edges), 
            k = concatNodes(k, f.nodes)) : (u = concatEdges(b, u, f.edges), n = concatNodes(n, f.nodes)), 
            l = f.pageInfo);
          }
          f.pageInfo.__typename !== l.__typename && (l.__typename = f.pageInfo.__typename);
          t !== f.__typename && (t = f.__typename);
        }
      }
      if ("string" == typeof t) {
        if (!ensureKey(b.resolve(a, e, c))) {
          if (d.store.schema) {
            d.partial = !0;
          } else {
            return;
          }
        }
        return {
          __typename: t,
          edges: "inwards" === g ? concatEdges(b, u, q) : concatEdges(b, q, u),
          nodes: "inwards" === g ? concatNodes(n, k) : concatNodes(k, n),
          pageInfo: {
            __typename: l.__typename,
            endCursor: l.endCursor,
            startCursor: l.startCursor,
            hasNextPage: l.hasNextPage,
            hasPreviousPage: l.hasPreviousPage
          }
        };
      }
    }
  };
};

exports.simplePagination = function(a) {
  var g, e, c;
  void 0 === a && (a = {});
  void 0 === (g = a.offsetArgument) && (g = "skip");
  void 0 === (e = a.limitArgument) && (e = "limit");
  c = function(a, d) {
    var b, c, v, t;
    for (b in d) {
      if (b !== g && b !== e) {
        if (!(b in a)) {
          return !1;
        }
        if (typeof (c = a[b]) != typeof (v = d[b]) || "object" != typeof c ? c !== v : core.stringifyVariables(c) !== core.stringifyVariables(v)) {
          return !1;
        }
      }
    }
    for (t in a) {
      if (t !== g && t !== e && !(t in d)) {
        return !1;
      }
    }
    return !0;
  };
  return function(a, d, e, m) {
    var b, t, u, q, n, k, l, p, h, f, r;
    b = m.fieldName;
    if (0 !== (u = (t = e.inspectFields(a = m.parentKey).filter((function(a) {
      return a.fieldName === b;
    }))).length)) {
      for (q = new Set, n = [], k = null, l = 0; l < u; l++) {
        h = (p = t[l]).fieldKey;
        if (null !== (p = p.arguments) && c(d, p) && (h = e.resolveFieldByKey(a, h), p = p[g], 
        null !== h && 0 !== h.length && "number" == typeof p)) {
          if (!k || p > k) {
            for (k = 0; k < h.length; k++) {
              q.has(f = h[k]) || (n.push(f), q.add(f));
            }
          } else {
            k = [];
            for (f = 0; f < h.length; f++) {
              q.has(r = h[f]) || (k.push(r), q.add(r));
            }
            n = k.concat(n);
          }
          k = p;
        }
      }
      if (e.resolve(a, b, d)) {
        return n;
      }
      if (m.store.schema) {
        return m.partial = !0, n;
      }
    }
  };
};
//# sourceMappingURL=urql-exchange-graphcache-extras.js.map
